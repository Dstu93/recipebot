
use std::io::Error;
use std::mem;

use recipe_manager::objects::{Recipe,Ingredient,Unit};
use recipe_manager::services::RecipeDAO;

use web_api::services::UserService;
use web_api::user::User;


pub struct RecipeDAOMock{
    recipes: Vec<Recipe>,
}

impl RecipeDAOMock {
    pub fn new() -> RecipeDAOMock {
        let mut recipes = Vec::with_capacity(30);
        RecipeDAOMock::fill_with_recipes(&mut recipes);
        RecipeDAOMock{recipes}
    }

    /// Fills a vec with test recipes
    pub fn fill_with_recipes(vec: &mut Vec<Recipe>) {
        
        let mut ingr = Vec::new();
        ingr.push(Ingredient::new("strawberrys".into(),Unit::Kilogramm,1.0));
        ingr.push(Ingredient::new("cake".into(),Unit::Kilogramm,0.5));
        let strawberry_cake = Recipe::with_ingredients(0,
            "Strawberry Cake".into(),
            "put all together, use glue".into(),5,
            ingr);
    
        let mut ingr = Vec::new();
        ingr.push(Ingredient::new("Schoclate".into(),Unit::Gramm,500.0));
        ingr.push(Ingredient::new("Milk".into(),Unit::Milliliter,500.0));
        let schoclate_cake = Recipe::with_ingredients(1,"Schoclate Cake".into(),"ask google".into(),5,ingr);

        vec.push(strawberry_cake);
        vec.push(schoclate_cake);
    }
}

impl RecipeDAO for RecipeDAOMock {
    /// Get All Recipes in the Database
    fn reciptes(&self) -> Result<Vec<Recipe>, Error>{
        Ok(self.recipes.clone())
    }
    /// Gets all Recipes that contains the given String in the name
    fn find_by_name(&self, name: &String) -> Result<Vec<Recipe>, Error>{
        let mut result = Vec::with_capacity(30);
        for recipe in &self.recipes{
            if recipe.name().contains(name){
                result.push(recipe.clone())
            }
        }
        Ok(result)
    }
    /// returns the Recipe with the given Id
    fn find_by_id(&self, id: &u32) -> Result<Recipe, Error>{
        unimplemented!("function is not supported");
    }
    /// Adds a Recipe to the Database, the id will be ignored and generated by the database/service 
    fn add(&mut self,recipe: &Recipe) -> Result<(), Error> {
        self.recipes.push(recipe.clone());
        Ok(())
    }
    /// Adds a collection of Recipes to the database, the id will be ignored and generate by the database/service
    fn add_all(&mut self, recipes: &Vec<Recipe>) -> Result<(),Error>{
        for recipe in recipes{
            self.recipes.push(recipe.clone());
        }
        Ok(())
    }
    /// Updates the Recipe with the given id.
    fn update(&mut self, recipe: &Recipe) -> Result<(),Error>{
        // add get and set to recipe
        for db_recipe in self.recipes.iter_mut() {
            if  db_recipe.id().eq(&recipe.id()){
                mem::replace(db_recipe,recipe.clone());
            }
        }
        Ok(())
    }
    /// Updates all Recipes with the given id.
    fn update_all(&mut self, recipes: &Vec<Recipe>) -> Result<(),Error>{
        unimplemented!("not supported");
    }
    /// Deletes the Recipe
    fn delete(&mut self,recipe: &Recipe) -> Result<(), Error>{
        let index = self.recipes.iter().position(|x| x.id().eq(&recipe.id()));
        if index.is_some() {
            self.recipes.remove(index.unwrap());
        }
        Ok(())
    }
}

/// Fake UserService, login: demo_user : password
pub struct UserServiceMock;

impl UserService for UserServiceMock {
        /// Add a new user to the user store
    fn create(&self, name: &String, password: &String) -> Result<bool,Error>{
        Ok(true)
    }

    /// add new admin user to the user store
    fn create_admin(&self, name: &String, password: &String) -> Result<bool,Error>{
        Ok(true)
    }

    /// search user with the given id.
    fn by_id(&self, id: i32) -> Result<Option<User>,Error>{
        Ok(None)
    }

    /// search user with given name. 
    fn by_name(&self, username: &String) -> Result<Option<User>,Error>{
        if "demo_user".eq(username){
            let user = User::new(32,String::from("demo_user"),Vec::new(),"".into(),false);
            Ok(Some(user))
        } else {Ok(None)}
    }

    /// deletes the user and all informations of and for the user from the database
    fn delete(&self, id: i32) -> Result<bool, Error>{
        Ok(false)
    } 

    /// checks the pw and the user name.
    fn authenticate(&self,name: &String, password: &String) -> Result<bool,Error>{
        println!("Prüfe ob Name {:?} und password {:?} übereinstimmen", name,password);
        if "demo_user".eq(name) && "password".eq(password){
            println!("Stimmen überein.");
            Ok(true)
        } else {Ok(false)}
    }

}